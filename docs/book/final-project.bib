@article{Han2003,
abstract = {A hard real-time system is usually subject to stringent reliability and timing constraints. One way to avoid missing deadlines is to trade the quality of computation results for timeliness, and software fault tolerance is often achieved with the use of redundant programs. A deadline mechanism which combines these two methods is proposed to provide software fault tolerance in hard real-time periodic task systems. We consider the problem of scheduling a set of real-time periodic tasks each of which has two versions: primary and alternate. The primary version contains more functions and produces good quality results, but its correctness is more difficult to verify. The alternate version contains only the minimum required functions and produces less precise results and its correctness is easy to verify. We propose a scheduling algorithm which 1) guarantees either the primary or alternate version of each critical task to be completed in time and 2) attempts to complete as many primaries as possible. Our basic algorithm uses a fixed priority-driven preemptive scheduling scheme to preallocate time intervals to the alternates and, at runtime, attempts to execute primaries first. An alternate will be executed only if necessary because of time or bugs.},
author = {Han, Ching Chih and Shin, Kang G. and Wu, Jian},
doi = {10.1109/TC.2003.1183950},
file = {:home/dancinggrass/Downloads/A Fault-Tolerant Scheduling Algorithm for Real-Time Periodic Tasks with Possible Software Faults.pdf:pdf},
isbn = {0018-9340},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Alternate,Backwards-RM algorithm,CAT algorithm,Deadline mechanisms,EIT algorithm,Notification time,Primary,Real-time systems},
number = {3},
pages = {362--372},
title = {{A fault-tolerant scheduling algorithm for real-time periodic tasks with possible software faults}},
volume = {52},
year = {2003}
}
@article{Shin2008,
abstract = {It is desirable to develop large complex systems using components based on systematic abstraction and composition. Our goal is to develop a compositional real-time scheduling framework to support abstraction and composition techniques for real-time aspects of components. In this paper, we present a formal description of compositional real-time scheduling problems, which are the component abstraction and composition problems. We identify issues that need be addressed by solutions and provide our framework for the solutions, which is based on the periodic interface. Specifically, we introduce the periodic resource model to characterize resource allocations provided to a single component. We present exact schedulability conditions for the standard Liu and Layland periodic task model and the proposed periodic resource model under EDF and RM scheduling, and we show that the component abstraction and composition problems can be addressed with periodic interfaces through the exact schedulability conditions. We also provide the utilization bounds of a periodic task set over the periodic resource model and the abstraction bounds of periodic interfaces for a periodic task set under EDF and RM scheduling. We finally present the analytical bounds of overheads that our solution incurs in terms of resource utilization increase and evaluate the overheads through simulations.},
author = {Shin, Insik and Lee, Insup},
doi = {10.1145/1347375.1347383},
file = {:home/dancinggrass/Downloads/shin2008.pdf:pdf},
isbn = {0-7695-2247-5},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {3},
pages = {1--39},
title = {{Compositional real-time scheduling framework with periodic model}},
url = {http://portal.acm.org/citation.cfm?doid=1347375.1347383},
volume = {7},
year = {2008}
}
@article{Hyun2012,
abstract = {As real-time systems become complex and require high-performance, Hierarchical Real-Time Scheduling Framework (HRTSF) has been investigated to schedule real-time tasks to meet their deadlines by sharing resources hierarchically under various scheduling algorithms. In this paper, we focus on fault-tolerant scheduling in the hierarchical real-time scheduling framework. Thus, we introduce a new component interface model which provides abstract information about a component's fault-tolerant real-time requirement. The upper-layer component can use the interface model to share its resource with consideration of both real-time and fault-tolerance. We also provide the schedulability analysis of Rate Monotonic (RM) algorithm under the proposed framework and apply it to a case study of designing avionics software as an example of Cyber Physical Systems (CPS). {\textcopyright} 2012 IEEE.},
author = {Hyun, Jongsoo and Kim, Kyong Hoon},
doi = {10.1109/RTCSA.2012.45},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Hyun, Kim - 2012 - Fault-tolerant scheduling in hierarchical real-time scheduling framework.pdf:pdf},
isbn = {978-1-4673-3017-6},
journal = {Proceedings - 18th IEEE International Conference on Embedded and Real-Time Computing Systems and Applications, RTCSA 2012 - 2nd Workshop on Cyber-Physical Systems, Networks, and Applications, CPSNA},
keywords = {Compositional,Fault-tolerant,Hierarchical,Real-time scheduling},
number = {i},
pages = {431--436},
title = {{Fault-tolerant scheduling in hierarchical real-time scheduling framework}},
year = {2012}
}
@article{Ghosh1997,
abstract = {Real time systems are being increasingly used in several$\backslash$napplications which are time critical in nature. Fault tolerance is an$\backslash$nimportant requirement of such systems, due to the catastrophic$\backslash$nconsequences of not tolerating faults. We study a scheme that provides$\backslash$nfault tolerance through scheduling in real time multiprocessor systems.$\backslash$nWe schedule multiple copies of dynamic, aperiodic, nonpreemptive tasks$\backslash$nin the system, and use two techniques that we call deallocation and$\backslash$noverloading to achieve high acceptance ratio (percentage of arriving$\backslash$ntasks scheduled by the system). The paper compares the performance of$\backslash$nour scheme with that of other fault tolerant scheduling schemes, and$\backslash$ndetermines how much each of deallocation and overloading affects the$\backslash$nacceptance ratio of tasks. The paper also provides a technique that can$\backslash$nhelp real time system designers determine the number of processors$\backslash$nrequired to provide fault tolerance in dynamic systems. Lastly, a formal$\backslash$nmodel is developed for the analysis of systems with uniform tasks},
author = {Ghosh, Sunondo and Melhem, Rami and Moss??, Daniel},
doi = {10.1109/71.584093},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Ghosh, Melhem, Moss{\'{e}} - 1997 - Fault-tolerance through scheduling of aperiodic tasks in hard real-time multiprocessor systems.pdf:pdf},
issn = {10459219},
journal = {IEEE Transactions on Parallel and Distributed Systems},
keywords = {Fault-tolerance,Operating systems,Primary/backup,Real-time scheduling,Redundancy,Reliability},
number = {3},
pages = {272--284},
title = {{Fault-tolerance through scheduling of aperiodic tasks in hard real-time multiprocessor systems}},
volume = {8},
year = {1997}
}
@article{Oh1994,
author = {Oh, Yingfeng and Son, Sang H},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Oh, Son - 1994 - Enhancing Fault-Tolerance in Rate-Monotonic Scheduling.pdf:pdf},
pages = {315--329},
title = {{Enhancing Fault-Tolerance in Rate-Monotonic Scheduling}},
volume = {329},
year = {1994}
}
@book{Tanenbaum2014,
abstract = {For software development professionals and computer science students, Modern Operating Systems gives a solid conceptual overview of operating system design, including detailed case studies of Unix/Linux and Windows 2000. Readers familiar with Tanenbaum's previous text, Operating Systems, know the author is a great proponent of simple design and hands-on experimentation. His earlier book came bundled with the source code for an operating system called Minux, a simple variant of Unix and the platform used by Linus Torvalds to develop Linux. Although this book does not come with any source code, he illustrates many of his points with code fragments (C, usually with Unix system calls). The first half of Modern Operating Systems focuses on traditional operating systems concepts: processes, deadlocks, memory management, I/O, and file systems. There is nothing ground-breaking in these early chapters, but all topics are well covered, each including sections on current research and a set of student problems. It is the second half of the book that differentiates itself from older operating systems texts. Here, each chapter describes an element of what constitutes a modern operating system-awareness of multimedia applications, multiple processors, computer networks, and a high level of security. The chapter on multimedia functionality focuses on such features as handling massive files and providing video-on-demand. Included in the discussion on multiprocessor platforms are clustered computers and distributed computing. Finally, the importance of security is discussed-a lively enumeration of the scores of ways operating systems can be vulnerable to attack, from password security to computer viruses and Internet worms. Included at the end of the book are case studies of two popular operating systems: Unix/Linux and Windows 2000. There is a bias toward the Unix/Linux approach, not surprising given the author's experience and academic bent, but this bias does not detract from Tanenbaum's analysis. Both operating systems are dissected, describing how each implements processes, file systems, memory management, and other operating system fundamentals. Tanenbaum's mantra is a simple, accessible operating system design. Given that modern operating systems have extensive features, he is forced to reconcile physical size with simplicity. Towards this end, he makes frequent references to the Frederick Brooks classic The Mythical Man Month for wisdom on managing large, complex software development projects. He finds both Windows 2000 and Unix/Linux guilty of being too complicated-with a particular skewering of Windows 2000 and its "mammoth Win32 API". A primary culprit is the attempt to make operating systems more "user-friendly," which Tanenbaum views as an excuse for bloated code. The solution is to have smart people, the smallest possible team, and well-defined interactions between various operating systems components. Future operating system design will benefit if the advice in this book is taken to heart. -Pete Ostenson - Dieser Text bezieht sich auf eine vergriffene oder nicht verf{\"{u}}gbare Ausgabe dieses Titels.},
archivePrefix = {arXiv},
arxivId = {0710.2023},
author = {Tanenbaum, Andrew S. and Bos, Herbert},
booktitle = {Education},
doi = {10.1142/S0129183108012261},
eprint = {0710.2023},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Tanenbaum, Bos - 2014 - Modern Operating Systems.pdf:pdf},
isbn = {9780133591620},
issn = {13541013},
number = {03},
pages = {1137},
pmid = {12204814},
title = {{Modern Operating Systems}},
url = {http://www.worldscientific.com/doi/abs/10.1142/S0129183108012261 http://www.amazon.com/dp/0136006639},
volume = {2},
year = {2014}
}
@article{Campbell1986,
abstract = {A real-time system must be reliable if a failure to meet its timing specifications might endanger human life, damage equipment, or waste expensive resources. Applications that require remote operation, timing accuracy, and long periods of activity need mechanisms to support reliability. Fault tolerance improves reliability by incorporating redundancy into the system design. A deadline mechanism has been proposed to provide fault tolerance in real-time software systems. The mechanism trades the accuracy of the results of a service for timing precision. Two independent algorithms are provided for each service subject to a deadline. The primary algorithm produces a good quality service, although its real-time reliability may not be assured. The alternate algorithm is reliable and produces an acceptable response. This paper introduces an algorithm to generate an optimal schedule for the deadline mechanism and discusses a simple and efficient implementation. The schedule ensures the timely completion of the alternate algorithm despite a failure to complete the primary algorithm within real time. {\textcopyright} 1986 IEEE},
author = {Liestman, Arthur L. and Campbell, Roy H.},
doi = {10.1109/TSE.1986.6312999},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Campbell - 1986 - A Fault-Tolerant Scheduling Problem.pdf:pdf},
isbn = {0818600209},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Real-time systems,scheduling,software fault tolerance,software reliability},
number = {11},
pages = {1089--1095},
title = {{A Fault-Tolerant Scheduling Problem}},
volume = {SE-12},
year = {1986}
}
@article{Choudhary2011,
abstract = {Software fault tolerance can itself be dangerous error-prone because of the additional effort that must be included in the programming process. The paper is based upon research in the area of testing software fault tolerance techniques. A Framework to Test Fault Tolerance has been proposed and validated with industry data. During the validation process we identified some of the interesting findings that can be explored to carry out further research in this area.},
author = {Choudhary, R. K. and Khan, R. A.},
doi = {10.1145/1968587.1968604},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Choudhary, Khan - 2011 - Testing Software Fault Tolerance Techniques- Future Direction.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {fault tolerance,framework,software faults,testing techniques},
number = {3},
pages = {1},
title = {{Testing software fault tolerance techniques}},
url = {http://portal.acm.org/citation.cfm?doid=1968587.1968604},
volume = {36},
year = {2011}
}
@article{AirlinesElectronicEngineeringCommittee2012,
abstract = {Subset services},
author = {{Airlines Electronic Engineering Committee}},
file = {:home/dancinggrass/Books/ARINC 653P1-3.pdf:pdf},
isbn = {ARINC Specification 653},
journal = {Arinc 653},
pages = {85},
title = {{653P1-3 Avionics Application Software Standard Interface Part 1 - Required Services}},
year = {2012}
}
@article{Al-Omari2004,
abstract = {In real-time systems, tasks have deadlines to be met despite the presence of faults. Primary-Backup (PB) scheme is one of the most important schemes that has been employed for fault-tolerant scheduling of real-time tasks, wherein each task has two versions and the versions are scheduled on two different processors with time exclusion. There have been techniques proposed for improving schedulability of the PB-based scheduling, of which Backup-Backup (BB) overloading is among the most popular ones. In this technique two or more backups can share/overlap in time on a processor. In this paper, we propose two new techniques that accommodate more tasks and/or tolerate faults effectively. In the first technique, called dynamic grouping, the processors are dynamically grouped into logical groups in order to achieve efficient overloading of tasks on resources, thereby improving the schedulability and the reliability of the system. In the second technique, called PB overloading, the primary of a task can share/overlap in time with the backup of another task on a processor. The intuition is that, for a primary (or backup), the PB-overloading can assign an earlier start time than that of the BB-overloading, thereby increasing the schedulability. We conduct schedulability and reliability analysis of the proposed techniques through simulation and analytical studies. Our studies show that dynamic grouping improves the schedulability more than static grouping, and offers graceful degradation with increasing faults. Also, PB-overloading improves the schedulability more than BB-overloading, and offers reliability comparable to that of BB-overloading. The proposed techniques are generic that they can be incorporated into many fault-tolerant non-preemptive scheduling algorithms. ?? 2004 Elsevier Inc. All rights reserved.},
author = {Al-Omari, Ra'ed and Somani, Arun K. and Manimaran, G.},
doi = {10.1016/j.jpdc.2004.03.015},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Omari, Somani, Manimaran - 2004 - Efficient overloading techniques for primary-backup scheduling in real-time systems.pdf:pdf},
issn = {07437315},
journal = {Journal of Parallel and Distributed Computing},
keywords = {Fault-tolerance,Multiprocessors,Real-time systems,Reliability,Schedulability,Scheduling},
number = {5},
pages = {629--648},
title = {{Efficient overloading techniques for primary-backup scheduling in real-time systems}},
volume = {64},
year = {2004}
}
@article{Rushby2000,
abstract = {Automated aircraft control has traditionally been divided into distinct "functions" that are implemented separately (e.g., autopilot, autothrottle, flight management); each function has its own fault-tolerant computer system, and dependencies among different functions are generally limited to the exchange of sensor and control data. A by-product of this "federated" architecture is that faults are strongly contained within the computer system of the function where they occur and cannot readily propagate to affect the operation of other functions. More modern avionics architectures contemplate supporting multiple functions on a single, shared, fault-tolerant computer system where natural fault containment boundaries are less sharply defined. Partitioning uses appropriate hardware and software mechanisms to restore strong fault containment to such integrated architectures. This report examines the requirements for partitioning, mechanisms for their realization, and issues in providing assurance for partitioning. Because partitioning shares some concerns with computer security, security models are reviewed and compared with the concerns of partitioning.},
author = {Rushby, John},
doi = {DOT/FAA/AR-99/58},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Rushby - 2000 - Partitioning in avionics architectures requirements, mechanisms and assurance.pdf:pdf},
journal = {Work},
number = {March},
pages = {67},
title = {{Partitioning in avionics architectures: requirements, mechanisms and assurance}},
year = {2000}
}
@inproceedings{Littlefield-Lawwill2008,
abstract = {Projeto de arquiteturas IMA considerando aspectos de particionamento (time-space partitioning)},
author = {Littlefield-Lawwill, Justin and Kinnan, Larry},
booktitle = {AIAA/IEEE Digital Avionics Systems Conference - Proceedings},
doi = {10.1109/DASC.2008.4702751},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Littlefield-Lawwill, Kinnan - 2008 - System considerations for robust time and space partitioning in integrated modular avionics.pdf:pdf},
isbn = {9781424422081},
pages = {1--11},
title = {{System considerations for robust time and space partitioning in integrated modular avionics}},
year = {2008}
}
@book{Chisnall2014,
abstract = {Xen is a virtualization tool, but what does this mean? In this chapter, we will explore some of the history of virtualization, and some of the reasons why people found, and continue to find, it useful. We will have a look in particular at the x86, or IA32, architecture, why it presents such a problem for virtualization, and some possible ways around these limitations from other virtualization systems and finally from Xen itself.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Chisnall, David},
booktitle = {Psychological Science},
doi = {10.1007/s13398-014-0173-7.2},
eprint = {arXiv:1011.1669v3},
file = {:home/dancinggrass/Books/System/Realtime Xen/00-The Definitive Guide to the Xen Hypervisor.pdf:pdf},
isbn = {9780874216561},
issn = {1467-9280},
keywords = {xen hypervisor virtualization},
month = {nov},
number = {9},
pages = {307},
pmid = {25052830},
title = {{The Definitive Guide to the Xen Hypervisor}},
url = {http://arxiv.org/abs/1011.1669 http://dx.doi.org/10.1088/1751-8113/44/8/085201 http://stacks.iop.org/1751-8121/44/i=8/a=085201?key=crossref.abc74c979a75846b3de48a5587bf708f http://www.ncbi.nlm.nih.gov/pubmed/15003161 http://www.ncbi.nlm.nih.gov/pubmed/150},
volume = {25},
year = {2014}
}
@article{Jin2013,
author = {Jin, Hyun-Wook},
doi = {10.1145/2583687.2583693},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Jin, Hyun-Wook - 2013 - Fault-tolerant hierarchical real-time scheduling with backup partitions on single processor.pdf:pdf},
issn = {15513688},
journal = {ACM SIGBED Review},
number = {4},
pages = {25--28},
title = {{Fault-tolerant hierarchical real-time scheduling with backup partitions on single processor}},
url = {http://dl.acm.org/citation.cfm?doid=2583687.2583693},
volume = {10},
year = {2013}
}
@inproceedings{Bertossi2006,
abstract = {This paper presents several fault-tolerant extensions of the Rate-Monotonic First-Fit multiprocessor scheduling algorithm handling both active and passive task copies. In particular, the technique of backup phasing delay is used to reduce the portions of active task copies that must be always executed and to deallocate active task copies as soon as their primary task copies have been successfully executed. It is also shown how to employ this technique while considering passive task duplication so as to over-book each processor with many passive task copies, assigning tasks to processors in such a way that tasks with equal or multiple periods have a high chance to be assigned to the same processor, and partitioning the processors into groups to avoid the mix of primary, active, and passive task copies on the same processor. Extensive simulations reveal a remarkable saving of both the overall number of processors used and the total computation time of the schedulability test (achieved especially by two new algorithms, called ARR3 and S-PR-PASS) with respect to previously proposed algorithms},
author = {Bertossi, Alan A. and Mancini, Luigi V. and Menapace, Alessandra},
booktitle = {Proceedings - IEEE International Symposium on Distributed Simulation and Real-Time Applications, DS-RT},
doi = {10.1109/DS-RT.2006.33},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Bertossi, Mancini, Menapace - 2006 - Scheduling hard-real-time tasks with backup phasing delay.pdf:pdf},
isbn = {0769526977},
issn = {15506525},
keywords = {Fault-tolerance,Hard-real-time systems,Multi-processors,Periodic tasks,Rate-monotonic scheduling},
pages = {107--116},
title = {{Scheduling hard-real-time tasks with backup phasing delay}},
year = {2006}
}
@article{Haritsa1992,
author = {Haritsa, Jayant R. and Carey, Michael J. and Livny, Miron},
doi = {10.1007/BF00365312},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Haritsa, Carey, Livny - 1992 - Data access scheduling in firm real-time database systems.pdf:pdf},
issn = {09226443},
journal = {Real-Time Systems},
number = {3},
pages = {203--241},
title = {{Data access scheduling in firm real-time database systems}},
volume = {4},
year = {1992}
}
@article{Garside2009,
abstract = {Traditionally, airplane systems have been designed and implemented in a federated fashion with each system providing for its own needs. A typical airplane system could be made up of one or more black boxes each having its own enclosure and providing for its own power conditioning and cooling needs. I/O signal conditioning and computational processing necessary to provide the intended function is also provided on a box-by-box basis. With each new generation of airplanes, the number of systems increased. Driven by market forces the need grew to reduce weight and electrical power to keep the airplane fuel efficient, cost-effective, and competitive. To address this contradiction, the Integrated Modular Avionics (IMA) concept was born. Within IMA architectures, avionics functions share common resources. Multiple black boxes are optimized to the minimum IMA resources necessary. This optimization provides the sought-after weight and power savings, and also provides for a much reduced number of parts to be maintained and controlled. These are all beneficial for the airplane manufacturer and airplane operator. However, MIMA architectures present some unique challenges during their development and integration. This will explore some of the more significant of these integration challenges associated with IMA architectures, including: What is the system? For the supplier whose system has been selected to be hosted on the IMA platform, the boundaries can be unclear. What was once a box with circuit cards and substance has been abstracted to a software application. Connection to other systems or to sensorsteffectors was via airplane wiring. Now, complex in-line electronics modules exist that the supplier knows little or nothing about. For the provider of the IMA platform, the system may be defined as a set of available resources (processing, communication, 1/0, etc.) to be shared by the systems to be hosted. To the airplane manufacturer the system is a working suite of avionics. - With the LMA approach: "Who is responsible for ensuring that boundaries and expectations are clearly defined and understood so that nothing gets overlooked?" Who is the system integrator? Within the IMA environment the answer changes depending on your perspective. The supplier of a hosted function may be considered responsible for the integration of their system components. The IMA platform provider may believe they are responsible for the platform elements. The airplane manufacturer wants an integrated solution. With the IMA approach: "Who is responsible for ensuring that the whole is equal to the sum of its parts?" How is the integration of an IMA architecture handled? As more and more of the hosted systems are brought together, IMA architectures can present challenges not seen with federated systems. The nature of IMA architectures requires more of the components to be available and working to allow seemingly simple tasks to take place. With the IMA approach: "Who is responsible for ensuring that this integration is planned and executed in the optimum sequence?"},
author = {Garside, Richard and Pighetti, F. Joe},
doi = {10.1109/MAES.2009.4811086},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Garside, Pighetti - 2009 - Integrating modular avionics A new role emerges.pdf:pdf},
isbn = {1424411084},
issn = {08858985},
journal = {IEEE Aerospace and Electronic Systems Magazine},
number = {3},
pages = {31--34},
title = {{Integrating modular avionics: A new role emerges}},
volume = {24},
year = {2009}
}
@inproceedings{VanderLeest2010,
abstract = {We have developed an early prototype of an ARINC 653 implementation using the virtualization technology of the open source Xen hypervisor along with a Linux-based domain/partition OS. In this paper we share lessons learned from adding to our prototype both an ARINC 653 CPU scheduler and a simple ARINC 653 serial I/O driver. By using a common hypervisor technology on multiple platforms, early application development can be done in a PC environment with relatively good modeling of the final target's behavior. The paper covers three topics. First, we start with an overview of the ARINC 653 standard, which is important because it reduces development costs, reduces system weight, and lowers certification costs. The standard focuses on resource partitioning of time and space on an avionics computer, managing the three primary subsystems of the computer: Central Processing Unit (CPU), Memory, and Input/Output (I/O). Second, we will review virtualization technology, an established method of sharing a computing resource, considering it for adaptation to ARINC 653. Third, as a case study, we will examine our prototype implementation of the ARINC 653 standard using the Xen open source hypervisor. We conclude with a discussion of our plans for future work towards ARINC 653 simulation and development environments on both PC desktop and embedded targets.},
author = {VanderLeest, Steven H.},
booktitle = {AIAA/IEEE Digital Avionics Systems Conference - Proceedings},
doi = {10.1109/DASC.2010.5655298},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/VanderLeest - 2010 - ARINC 653 hypervisor.pdf:pdf},
isbn = {9781424466160},
issn = {2155-7195},
title = {{ARINC 653 hypervisor}},
year = {2010}
}
@article{Shin1994,
abstract = {This paper surveys the state of the art in real-time computing. It$\backslash$nintroduces basic concepts and identifies key issues in the design of$\backslash$nreal-time systems. Solutions proposed in literature for tackling these$\backslash$nissues are also briefly discussed},
author = {Shin, Kang G. and Ramanathan, Parameswaran},
doi = {10.1109/5.259423},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Shin, Ramanathan - 1994 - Real-Time Computing A New Discipline of Computer Science and Engineering.pdf:pdf},
issn = {15582256},
journal = {Proceedings of the IEEE},
number = {1},
pages = {6--24},
pmid = {16856666},
title = {{Real-Time Computing: A New Discipline of Computer Science and Engineering}},
volume = {82},
year = {1994}
}
@online{Larry2009,
author = {Larry M. Kinnan},
title  = {Linux, ARINC 653 and OpenGL Team Up for Avionics Prototyping},
url    = {http://archive.cotsjournalonline.com/articles/print_article/100736},
year   = {2009}
}
@online{POSIX,
author = {{Institute of Electrical and Electronics Engineers}},
title  = {IEEE Std 1003.1™-2008 and The Open Group Technical Standard Base Specifications, Issue 7},
url    = {http://pubs.opengroup.org/onlinepubs/9699919799/},
year   = {2016}
}
@online{RTLinux,
author = {{The Linux Foundation}},
title  = {The Real Time Linux collaborative project},
url    = {https://wiki.linuxfoundation.org/realtime/documentation},
year   = {2017}
}
@article{Adamczyk2015,
abstract = {Virtual Machine Monitors (VMM) have become popular in different application areas. Some applications may require to generate the timer events with high resolution and precision. This however may be challenging due to the complexity of VMMs. In this paper we focus on the timer functionality provided by five different VMMs-Xen, KVM, Qemu, VirtualBox and VMWare. Firstly, we evaluate resolutions and precisions of their timer events. Apparently, provided resolutions and precisions are far too low for some applications (e.g. networking applications with the quality of service). Then, using Xen virtualization we demonstrate the improved timer design that greatly enhances both the resolution and precision of achieved timer events.},
author = {Adamczyk, Blazej and Chydzinski, Andrzej},
doi = {10.1371/journal.pone.0130887},
file = {:home/dancinggrass/Books/System/Realtime Xen/pone.0130887 (8).pdf:pdf},
isbn = {19326203 (Electronic)},
issn = {19326203},
journal = {PLoS ONE},
number = {7},
pages = {1--25},
pmid = {26177366},
title = {{Achieving high resolution timer events in virtualized environment}},
volume = {10},
year = {2015}
}
@article{Broomhead2010,
abstract = {We propose a new timekeeping architecture for virtu- alized systems, in the context of Xen. Built upon a feed- forward based RADclock synchronization algorithm, it ensures that the clocks in each OS sharing the hardware derive from a single central clock in a resource effective way, and that this clock is both accurate and robust. A key advantage is simple, seamless VM migration with consistent time. In contrast, the current Xen approach for timekeeping behaves very poorly under live migra- tion, posing a major problem for applications such as fi- nancial transactions, gaming, and network measurement, which are critically dependent on reliable timekeeping. We also provide a detailed examination of the HPET and Xen Clocksource counters. Results are validated using a hardware-supported testbed.},
author = {Broomhead, Timothy and Cremean, L. and Ridoux, J. and Veitch, D.},
file = {:home/dancinggrass/Downloads/Broomhead.pdf:pdf},
journal = {Proceedings of the 9th USENIX conference on Operating systems design and implementation},
pages = {1--6},
title = {{Virtualize everything but time}},
url = {http://www.usenix.org/events/osdi/tech/full{\_}papers/Broomhead.pdf},
year = {2010}
}
