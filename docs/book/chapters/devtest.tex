%! TEX root = ../final-project.tex
\chapter{PENGEMBANGAN DAN PENGUJIAN}

\section{Pengembangan \textit{Primary-Backup Partition Scheduling}}

Pengembangan dilakukan dengan memodifikasi kode \textit{scheduler} ARINC 653
\textit{source-tree} pada Xen ARINC 653.  Modifikasi kode dilakukan pada modul-modul berikut.

\begin{enumerate}

	\item Modul Libxl

	Modul ini digunakan untuk membuat \textit{tools} yang dapat digunakan pada \textit{user
	space} \textit{domain} \code{dom0} untuk melakukan pengaturan \textit{hypervisor}.

	\item Modul Libxc

	Modul ini berisi fungsi-fungsi untuk menangani permintaan \textit{hypercall} dari
	\textit{domain}.

	\item Modul \textit{Public hypercall}

	Modul ini berisi definisi \textit{interface} yang digunakan untuk mengatur struktur data
	yang dikirimkan pada saat mengirim data dari \textit{domain} kepada \textit{hypervisor}.

	\item Modul \textit{Scheduler}

	Modul ini berisi fungsi-fungsi yang digunakan untuk mengisi definisi \textit{interface}
	\textit{scheduler} pada Xen. Fungsi-fungsi tersebut meliputi algoritma
	\textit{scheduler}, penanganan \textit{hypercall} terhadap \textit{scheduler}.

\end{enumerate}

Agar algoritma \textit{primary-backup partition scheduling} yang dijelaskan pada
\autoref{section:solution} dapat berjalan dengan seharusnya, perlu ada mekanisme penanganan data
yang dibutuhkan pada masing-masing domain. Hal tersebut dapat dicapai dengan mendefinisikan
struktur data yang dapat dimengerti oleh \textit{hypervisor} dan \textit{user space} untuk
berkomunikasi melalui \textit{hypercall}, membuat struktur data untuk menggunakan
\textit{hypercall}, membuat mekanisme pengiriman data melalui \textit{hypercall}, membuat
struktur data untuk menyimpan informasi \textit{domain} pada \textit{scheduler}, serta mengubah
data yang didapat oleh \textit{hypervisor} setelah menangani \textit{hypercall} sesuai dengan
struktur data \textit{domain} pada \textit{scheduler}.

Implementasi mekanisme pengiriman data dari \textit{user space} kepada \textit{hypervisor} akan
dipaparkan pada \autoref{section:modul_libxl}. Mekanisme \textit{hypercall} yang
diimplementasikan akan dipaparkan pada \autoref{section:modul_libxc}. Pendefinisian struktur
data yang digunakan pada saat melakukan \textit{hypercall} akan dipaparkan pada
\autoref{section:modul_public_hypercall}. Mekanisme konversi data yang didapat oleh
\textit{hypervisor} setelah menangani \textit{hypercall} serta definisi struktur data
masing-masing \textit{domain} pada \textit{scheduler} akan dijelaskan pada
\autoref{section:modul_scheduler_arinc653}.

Penjelasan akan dilakukan secara \textit{bottom-up} dimulai dari definisi
\textit{interface}/struktur data, kemudian fungsi dari \textit{interface}/struktur data yang
sudah didefinisikan. Masing-masing mekanisme akan dijelaskan apabila seluruh
\textit{interface}/struktur data yang digunakan pada mekanisme tersebut telah dipaparkan. Secara
garis besar, penjelasan akan dilakukan dimulai dari bagian \textit{low-level} dan
\textit{high-level} pada \textit{hypervisor}, kemudian memasuki bagian \textit{low-level} dan
\textit{high-level} pada \textit{user space}. Urutan penjelasan dilakukan sedemikian dengan
harapan akan mempermudah pembaca dalam mengerti masing-masing langkah yang akan dipaparkan pada
setiap mekanisme.

\subsection{Modul \textit{scheduler}}
\label{section:modul_scheduler_arinc653}

Subbab ini akan membahas implementasi dari \textit{primary-backup partition scheduling} pada
modul \textit{scheduler}. Implementasi \textit{scheduler} pada ARLX meliputi tiga buah
bagian.

\begin{enumerate}
	
	\item Pendefinisian \textit{scheduler}

		Pada ARLX, algoritma \textit{scheduling} yang akan digunakan \textit{hypervisor}
		untuk menjadwalkan partisi dapat dipilih pada saat \textit{boot}. Hal ini
		mempermudah dalam melakukan uji coba layanan dengan \textit{scheduler} tertentu
		guna menentukan algoritma \textit{scheduling} yang akan digunakan.
		
	\item Informasi partisi

		\textit{Scheduler} ARINC 653 yang terdapat pada ARLX tidak memerlukan informasi
		mengenai partisi. Pengguna hanya perlu memberikan daftar partisi beserta batasan
		\textit{real-time} yang harus dipenuhi. Daftar tersebut diberikan melalui
		\textit{global hypercall}, yaitu \textit{hypercall} yang tidak dalam konteks
		partisi tertentu. \textit{Primary-backup partition scheduling} memerlukan
		informasi mengenai partisi tertentu seperti yang telah dijelaskan pada
		\autoref{section:informasi_partisi}. Dengan demikian, \textit{scheduler}
		memerlukan implementasi \textit{hypercall} spesifik domain agar \textit{user
		space} dapat mengatur informasi partisi pada \textit{scheduler}. Untuk
		selanjutnya, \textit{hypercall} akan mengacu pada \textit{hypercall spesifik
		domain} karena \textit{global hypercall} tidak relevan dengan tugas akhir ini.
		
	\item Fungsi \textit{scheduling}

		Algoritma \textit{scheduling} pada ARLX diimplementasikan dengan mendefinisikan
		fungsi yang memiliki deklarasi seperti pada
		\autoref{code:do_schedule_declaration}. Fungsi tersebut kemudian akan dipanggil
		apabila \textit{hypervisor} menerima \textit{timer interrupt} atau partisi yang
		sedang mendapatkan waktu CPU telah menghabiskan quantum waktu miliknya.

\end{enumerate}

\begin{figure}[!ht]
\begin{lstlisting}[
	caption={Deklarasi fungsi \textit{scheduling} pada ARLX},
	label=code:do_schedule_declaration
]
struct task_slice (*do_schedule) (const struct scheduler *, s_time_t,
                                  bool_t tasklet_work_scheduled);
\end{lstlisting}
\end{figure}

\subsubsection{Pendefinisian \textit{scheduler}}
\label{section:definisi_scheduler}

Pada Xen, pendefinisian \textit{scheduler} dilakukan dengan menggunakan \textit{interface} yang
telah disediakan~\citep[p.~218]{Chisnall2014}. \autoref{code:struct_scheduler} menampilkan
\textit{interface} tersebut. \textit{Interface} tersebut kemudiakan didefinisikan sebagai
struktur pada saat \textit{runtime} dengan masing-masing \textit{function pointer} menunjuk pada
sebuah fungsi.

\begin{figure}[!ht]
\begin{lstlisting}[
	caption={\textit{Interface} dari fungsi \textit{scheduler}},
	label=code:struct_scheduler
]
struct scheduler {
    char ∗name ;
    char ∗opt name ;
    unsigned int sched id ;

    void         (*free_domdata)   (const struct scheduler *, void *);
    void *       (*alloc_domdata)  (const struct scheduler *, struct domain *);
    int          (*init_domain)    (const struct scheduler *, struct domain *);
    void         (*destroy_domain) (const struct scheduler *, struct domain *);

    struct task_slice (*do_schedule) (const struct scheduler *, s_time_t,

    int          (*adjust)         (const struct scheduler *, struct domain *,
    int          (*adjust_global)  (const struct scheduler *,
};
\end{lstlisting}
\end{figure}

Setiap fungsi yang ditunjuk oleh \textit{function pointer} pada struktur
tersebut akan berlaku sebagai \textit{handler} yang akan dipanggil oleh \textit{hypervisor}
apabila terjadi \textit{event} yang bersesuaian. Asosiasi antara \textit{handler} dan
\textit{event} telah ditentukan sebelumnya. Setiap \textit{handler} pada struktur tersebut
kemudian diisi dengan alamat dari fungsi yang nantinya akan menangani permintaan pada
\textit{scheduler}. Setiap \textit{scheduler} diharuskan mengisi \textit{handler}
\code{do\_schedule()}. Apabila \textit{scheduler} tidak memerlukan sebuah \textit{handler}, maka
\textit{handler} dapat diisi dengan nilai \code{NULL}.

Pada saat \textit{boot}, konfigurasi \textit{scheduler} yang diinginkan dapat dipilih dengan
menambahkan argumen "sched=\{scheduler\}". \textit{Hypervisor} kemudian akan mencari
\textit{scheduler} didefinisikan dengan nilai \code{opt\_name} sama dengan "scheduler".

\subsubsection{Informasi Partisi}
\label{section:informasi_partisi_impl}

Untuk mengimplementasikan \textit{scheduler}, \textit{function pointer} \code{do\_schedule()}
harus diisi dengan alamat dari fungsi yang akan melakukan pemilihan partisi. Pada implementasi
\textit{primary-backup partition scheduler}, \textit{function pointer} tersebut akan diisi
dengan alamat dari fungsi \code{a653sched\_do\_schedule()} yang akan dipaparkan pada
\autoref{section:scheduling_impl}. Agar \textit{hypervisor} dapat mengenali \textit{scheduler}
yang diimplementasikan, \code{opt\_name} akan diberi nilai "arinc653pb". Dengan demikian,
\textit{primary-backup partition scheduler} dapat digunakan dengan cara memberikan parameter
"sched=arinc653pb" pada \textit{hypervisor} ketika \textit{boot}.

\begin{figure}[!ht]
\begin{lstlisting}[
	caption={Struktur untuk menyimpan informasi partisi},
	label=code:struct_a653sched_domain_t
]
typedef struct a653sched_domain_s {
    domid_t parent;
    bool primary;
    bool healthy;
} a653sched_domain_t;
\end{lstlisting}
\end{figure}

Pada implementasi \textit{primary-backup scheduler}, informasi partisi akan disimpan pada
struktur data seperti yang ditampilkan oleh \autoref{code:struct_a653sched_domain_t}.
\textit{Scheduler} mengetahui keadaan partisi apabila partisi tersebut memberikan informasi
tentang dirinya melalui \textit{hypercall} yang akan didefinisikan pada
\autoref{section:modul_public_hypercall}.

\begin{figure}[!hb]
\begin{lstlisting}[
	caption={Fungsi inisialisasi partisi},
	label=code:init_domain
]
static int
a653sched_init_domain(const struct scheduler *ops,
                     struct domain *dom)
{
    a653sched_domain_t *sdom;

    sdom = xzalloc(a653sched_domain_t);
    if ( sdom == NULL )
        return -ENOMEM;

    sdom->parent = dom->domain_id;
    sdom->primary = true;
    sdom->healthy = true;

    dom->sched_priv = sdom;

    return 0;
}
\end{lstlisting}
\end{figure}

Pada saat pembuatan partisi, \textit{scheduler} akan memanggil fungsi yang ditunjuk oleh
\textit{function pointer} \code{init\_domain} pada struktur yang telah dijelaskan pada
\autoref{section:definisi_scheduler}. Tujuan fungsi tersebut adalah untuk mengalokasikan memori
serta menginisialisasi informasi partisi pada saat dibuat. Fungsi tersebut diimplementasikan
seperti pada \autoref{code:init_domain}. Setelah dibuat, informasi partisi akan memiliki nilai
awal yang menandakan bahwa partisi tersebut sehat dan partisi tersebut memberikan layanan sesuai
dengan identifikasi sama dengan identifikasi partisi tersebut.


\begin{figure}[!ht]
\begin{lstlisting}[
	caption={Fungsi penghapusan partisi},
	label=code:destroy_domain
]
static void
a653sched_destroy_domain(const struct scheduler *ops, struct domain *dom)
{
    dom->sched_priv = NULL;

    xfree(dom->sched_priv);
}
\end{lstlisting}
\end{figure}

Pada saat penghapusan partisi, \textit{scheduler} akan memanggil fungsi yang ditunjuk oleh
\textit{function pointer} \code{destroy\_domain} pada struktur yang telah dijelaskan pada
\autoref{section:definisi_scheduler}. Tujuan fungsi tersebut adalah untuk dealokasi memori yang
digunakan oleh informasi partisi yang tersimpan pada \textit{scheduler}. Dealokasi memori akan
membuat pengaksesan memori tersebut mengakibatkan kegagalan pada \textit{hypervisor} sehingga
\textit{hypervisor} akan berhenti bekerja. Karena itu, memori tempat penyimpanan struktur
informasi partisi milik partisi yang dihapus tidak boleh diakses lagi. Fungsi tersebut hanya
akan dipanggil apabila terdapat \textit{interrupt} yang meminta agar \textit{domain} tersebut
dihapus. Maka, penggunaan informasi partisi sebaiknya dimulai dengan permintaan \textit{lock}
dan mematikan \textit{interrupt}, kemudian pada saat pembacaan maupun penulisan melakukan
pengecekan nilai \textit{pointer} untuk memastikan informasi partisi masih valid, dan diakhiri
dengan pelepasan \textit{lock} dan menyalakan \textit{interrupt}.

\subsubsection{Fungsi \textit{Scheduling}}
\label{section:scheduling_impl}

Algoritma \textit{scheduling} yang akan digunakan pada \textit{primary-backup partition
scheduler} memiliki banyak kesamaan dengan algoritma \textit{scheduling} yang digunakan oleh
\textit{scheduler} ARINC 653 pada ARLX. Dengan demikian, implementasi algoritma
\textit{scheduling} akan menggunakan fungsi yang sudah ada pada \textit{scheduler} ARINC 653
yang kemudian dimodifikasi sehingga bekerja sebagaimana telah dipaparkan pada
\autoref{section:algoritma_scheduling}.

Karena fungsi \textit{scheduling} akan dipanggil setiap kali sebuah partisi menghabiskan kuantum
waktu atau \textit{hypervisor} mendapatkan \textit{timer interrupt}, keadaan algoritma pada
fungsi \textit{scheduling} harus bersifat tetap pada setiap pemanggilan. Fungsi
\textit{scheduling} ARINC 653 pada ARLX memiliki kompleksitas waktu $O(1)$ untuk setiap
pemanggilan. Untuk menjaga efisiensi kinerja sistem secara keseluruhan, algoritma
\textit{scheduling} pada \textit{primary-backup partition scheduler} diimplementasikan
sedemikian sehingga memiliki kompleksitas waktu yang sama dengan algoritma \textit{scheduling}
pada \textit{scheduler} ARINC 653.

\begin{figure}
\begin{lstlisting}[
	caption={Implementasi algoritma \textit{scheduling}},
	label=code:fungsi_scheduling,
	linerange={bdata-edata,balgo-ealgo},
	escapeinside={(*@}{@*)}
]
static struct task_slice
a653sched_do_schedule(
    const struct scheduler *ops,
    s_time_t now,
    bool_t tasklet_work_scheduled)
{
    struct task_slice ret;                      /* hold the chosen domain */
    struct vcpu * new_task = NULL;
    static unsigned int sched_index = 0;
    static s_time_t next_switch_time;
    a653sched_priv_t *sched_priv = SCHED_PRIV(ops);
    const unsigned int cpu = smp_processor_id();
    { bdata }
    (*@{$\cdots$}@*)
    static bool task_done[ARINC653_MAX_DOMAINS_PER_SCHEDULE] = {0};
    static a653sched_domain_t * dom_priv = NULL;
    unsigned long flags;
    (*@{$\cdots$}@*)
    { edata }

    spin_lock_irqsave(&sched_priv->lock, flags);

    if ( sched_priv->num_schedule_entries < 1 )
        sched_priv->next_major_frame = now + DEFAULT_TIMESLICE;
    { balgo }
    else if ( now >= sched_priv->next_major_frame )
    {
        sched_index = 0;
        sched_priv->next_major_frame = now + sched_priv->major_frame;
        next_switch_time = now + sched_priv->schedule[0].runtime;
        dom_priv = DOM_PRIV(sched_priv->schedule[0].vc->domain);
        memset(task_done, 0, sizeof(task_done));
    }
    else
    {
        if ( now >= next_switch_time) 
            task_done[dom_priv->parent] = true;

        while ( ( (now >= next_switch_time)
                || (!dom_priv->healthy)
                || (task_done[dom_priv->parent]) )
                && (sched_index < sched_priv->num_schedule_entries) )
        {
            /* time to switch to the next domain in this major frame */
            sched_index++;
            if (sched_index < sched_priv->num_schedule_entries) {
                dom_priv = DOM_PRIV(sched_priv->schedule[sched_index].vc->domain);
                if (!task_done[dom_priv->parent])
                    next_switch_time += sched_priv->schedule[sched_index].runtime;
            }
        }
    }
    (*@{$\cdots$}@*)
    { ealgo }
}
\end{lstlisting}
\end{figure}

\subsection{Modul \textit{public hypercall}}
\label{section:modul_public_hypercall}

Subbab ini akan membahas implementasi dan modifikasi pada modul public \textit{hypercall} agar
dapat mengimplementasikan \textit{hypercall} sebagai metode komunikasi dan pemindahan data
antara \textit{user space} dengan \textit{hypervisor} terkait informasi informasi partisi
seperti yang sudah dibahas pada \autoref{section:informasi_partisi}.

\begin{figure}
\begin{lstlisting}[
	caption={Data struktur untuk komunikasi yang dapat dimengerti \newline \textit{scheduler} dan \textit{user space}},
	label=code:struct_xen_domctl_sched_arinc653
]
typedef struct xen_domctl_sched_arinc653 {
    domid_t parent;
    uint8_t healthy;
} xen_domctl_sched_arinc653_t;
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[
	caption={Data struktur untuk pemindahan data pada saat \textit{hypercall}},
	label=code:struct_xen_domctl_scheduler_op
]
struct xen_domctl_scheduler_op {
    uint32_t sched_id;
    uint32_t cmd;

    union {
        xen_domctl_sched_credit_t credit;
        xen_domctl_sched_credit2_t credit2;
        xen_domctl_sched_rtds_t rtds;
        xen_domctl_sched_arinc653_t arinc653;
        struct {
            XEN_GUEST_HANDLE_64(xen_domctl_schedparam_vcpu_t) vcpus;
            uint32_t nr_vcpus;
            uint32_t padding;
        } v;
    } u;
};
\end{lstlisting}
\end{figure}

Implementasi \textit{hypercall} dilakukan dengan mendeklarasikan struktur seperti pada
\autoref{code:struct_xen_domctl_sched_arinc653}. Deklarasi struktur tersebut bertujuan agar
terdapat \textit{interface} struktur data yang dapat dimengerti oleh \textit{scheduler} dan
\textit{user space} sehingga keduanya dapat berkomunikasi. Struktur tersebut kemudian menjadi
salah satu \textit{union member} pada struktur generik yang digunakan oleh \textit{Xen} untuk
pemindahan data. Struktur tersebut dapat dilihat pada
\autoref{code:struct_xen_domctl_scheduler_op}. Metode transfer informasi partisi menggunakan
struktur tersebut akan dipaparkan pada \autoref{section:modul_libxc}.

\subsection{Modul libxc}
\label{section:modul_libxc}

Subbab ini akan membahas implementasi dan modifikasi pada modul libxc, yaitu modul yang
menangani komunikasi antara \textit{hypervisor} dengan \textit{user space} pada
\textit{low-level}. Fungsi-fungsi pada libxc akan dikompilasi menjadi sebuah \textit{library}
milik sistem sehingga seluruh \textit{tools} pada \textit{user space} dapat menggunakan
fungsi-fungsi yang terdapat pada libxc. Modifikasi pada modul libxc diperlukan agar \textit{user
space} mengetahui cara untuk berkomunikasi dengan \textit{scheduler} yang akan dibuat.

Agar \textit{primary-backup partition scheduling} dapat bekerja, \textit{libxc} harus dapat
berkomunikasi dua arah dengan \textit{hypervisor}. Komunikasi dilakukan dengan mengirimkan
struktur \autoref{code:struct_xen_domctl_scheduler_op} melalui \textit{hypercall}.
\textit{Member} \code{sched\_id} pada struktur tersebut diberi nilai yang menandakan bahwa
struktur yang dikirimkan melalui \textit{hypercall} tersebut ditujukan untuk komponen
\textit{scheduler}. Kemudian, \textit{member} \code{cmd} akan diberi nilai yang menandakan
apakah \textit{user space} akan mengirimkan informasi partisi kepada \textit{scheduler} atau
meminta informasi partisi dari \textit{scheduler}.

Implementasi fungsi untuk mengirimkan informasi partisi kepada \textit{scheduler} oleh \textit{user
space} dapat dilihat pada \autoref{code:xc_sched_sysctl_set} sedangkan fungsi untuk meminta
informasi dari \textit{scheduler} oleh \textit{user space} dapat dilihat pada
\autoref{code:xc_sched_sysctl_get}.

\subsubsection{Fungsi Pengiriman Informasi Partisi}

\begin{figure}[!ht]
\begin{lstlisting}[
	caption={Fungsi yang digunakan \textit{user space} mengirim informasi \newline kepada \textit{scheduler}},
	label=code:xc_sched_sysctl_set
]
int
xc_sched_arinc653_domain_set(
    xc_interface *xch,
    uint32_t domid,
    struct xen_domctl_sched_arinc653 *sdom)
{
    int rc;
    DECLARE_DOMCTL;

    domctl.cmd = XEN_DOMCTL_scheduler_op;
    domctl.domain = (domid_t) domid;
    domctl.u.scheduler_op.sched_id = XEN_SCHEDULER_ARINC653;
    domctl.u.scheduler_op.cmd = XEN_DOMCTL_SCHEDOP_putinfo;
    domctl.u.scheduler_op.u.arinc653 = *sdom;

    rc = do_domctl(xch, &domctl);

    return rc;
}
\end{lstlisting}
\end{figure}

Fungsi untuk mengirimkan informasi partisi kepada \textit{scheduler} membutuhkan identifikasi
partisi dan struktur yang akan dikirim melalui \textit{hypercall}. Identifikasi partisi harus
berupa nilai yang valid (terdapat partisi yang memiliki identifikasi dengan nilai tersebut) agar
pemanggilan \textit{hypercall} berhasil. Struktur yang dikirim adalah struktur yang dapat
dimengerti oleh \textit{scheduler} seperti yang telah ditampilkan pada
\autoref{code:struct_xen_domctl_scheduler_op}.

Fungsi pada \autoref{code:xc_sched_sysctl_set} diimplementasikan dengan meminta alokasi memori
pada \textit{hypervisor} yang berkorespondensi dengan memori pada \textit{user space}.
Permintaan tersebut dilakukan dengan menggunakan \textit{macro} \code{DECLARE\_DOMCTL}. Dengan
menggunakan hasil dari alokasi memori, \textit{hypervisor} dapat menyalin isi dari memori pada
\textit{user space} menjadi isi dari memori korespondensinya pada \textit{hypervisor}.

\subsubsection{Fungsi Permintaan Informasi Partisi}
\label{section:fungsi_permintaan_informasi_partisi}

\begin{figure}[!ht]
\begin{lstlisting}[
	caption={Fungsi yang digunakan \textit{user space} meminta informasi \newline partisi dari \textit{scheduler}},
	label=code:xc_sched_sysctl_get
]
int
xc_sched_arinc653_domain_get(
    xc_interface *xch,
    uint32_t domid,
    struct xen_domctl_sched_arinc653 *sdom)
{
    int rc;
    DECLARE_DOMCTL;

    domctl.cmd = XEN_DOMCTL_scheduler_op;
    domctl.domain = (domid_t) domid;
    domctl.u.scheduler_op.sched_id = XEN_SCHEDULER_ARINC653;
    domctl.u.scheduler_op.cmd = XEN_DOMCTL_SCHEDOP_getinfo;

    rc = do_domctl(xch, &domctl);

    if ( rc == 0 )
        *sdom = domctl.u.scheduler_op.u.arinc653;

    return rc;
}
\end{lstlisting}
\end{figure}

Fungsi untuk meminta informasi partisi kepada \textit{scheduler} membutuhkan identifikasi
partisi dan memori yang akan digunakan untuk menyimpan informasi partisi yang didapat melalui
\textit{hypercall}. Identifikasi partisi harus berupa nilai yang valid (terdapat partisi yang
memiliki identifikasi dengan nilai tersebut) agar pemanggilan \textit{hypercall} berhasil.
Ukuran dari memori yang digunakan untuk melakukan \textit{hypercall} harus sama dengan ukuran
struktur pada \autoref{code:struct_xen_domctl_scheduler_op}.

Fungsi tersebut diimplementasikan seperti pada \autoref{code:xc_sched_sysctl_get}. Secara umum
implementasi fungsi tersebut sama seperti impementasi fungsi permintaan informasi partisi
seperti pada \autoref{section:fungsi_permintaan_informasi_partisi}. Perbedaannya hanya pada
nilai yang digunakan oleh \textit{hypervisor} untuk menentukan arah komunikasi
\textit{hypercall}.

\subsection{Modul libxl}
\label{section:modul_libxl}

Subbab ini akan membahas implementasi dan modifikasi pada modul libxl, yaitu modul yang
menangani konfigurasi \textit{domain} pada \textit{high-level}. Libxl digunakan untuk membangun
kakas xl yang digunakan oleh administrator sistem untuk mengubah konfigurasi terkait dengan
\textit{hypervisor} melalui \textit{user space}. Fungsionalitas yang ditawarkan libxl pada
umumnya menggunakan fungsi-fungsi yang ditawarkan oleh libxc.

Modifikasi yang dilakukan pada libxl adalah menambahkan opsi pada xl sehingga administrator
dapat mengubah informasi mengenai partisi dan memanggil fungsi yang digunakan untuk
berkomunikasi dengan \textit{hypervisor} melalui \textit{user space}. libxl akan memanggil kode
libxc seperti pada \autoref{code:xl_domain_getset}. Kode tersebut memanggil fungsi-fungsi telah
dibahas sebelumnya pada \autoref{section:modul_libxc}.

\begin{figure}[!ht]
\begin{lstlisting}[
	caption={xl berkomunikasi dengan menggunakan fungsi milik xc},
	label=code:xl_domain_getset
]
static int sched_arinc653_domain_get(libxl__gc *gc, uint32_t domid,
                                   libxl_domain_sched_params *scinfo)
{
    struct xen_domctl_sched_arinc653 sdom;
    int rc;

    rc = xc_sched_arinc653_domain_get(CTX->xch, domid, &sdom);

    libxl_domain_sched_params_init(scinfo);
    scinfo->sched = LIBXL_SCHEDULER_ARINC653;
    scinfo->parent = sdom.parent;
    scinfo->healthy = sdom.healthy;

    return rc;
}

static int sched_arinc653_domain_set(libxl__gc *gc, uint32_t domid,
                                     const libxl_domain_sched_params *scinfo)
{
    struct xen_domctl_sched_arinc653 sdom;
    int rc;

    rc = xc_sched_arinc653_domain_get(CTX->xch, domid, &sdom);
    if (rc != 0) {
        LOGE(ERROR, "getting domain sched arinc653");
        return ERROR_FAIL;
    }

    if (scinfo->parent != LIBXL_DOMAIN_SCHED_PARAM_PARENT_DEFAULT)
        sdom.parent = scinfo->parent;
    sdom.healthy = scinfo->healthy;
    rc = xc_sched_arinc653_domain_set(CTX->xch, domid, &sdom);

    return rc;
 }
\end{lstlisting}
\end{figure}

% \section{Pengujian}

% Pengujian dilakukan dengan mengukur keandalan sistem seperti yang sudah
% We tested the primary-backup ARINC 653 scheduler by having five partitions, named as P1 to P5.
% The first two partitions (P1 and P2) provide service $A$ and the last three partitions (P3, P4,
% and P5) provide service $B$. The testing scenarios on these partitions, including the expected
% outcome, are as follows:

% \begin{enumerate}

% 	\item Initially, all five partitions are healthy. In this scenario, the scheduler are
% 		supposed to selects partition P1 and partition P3.

% 	\item Partition P3 experienced a failure. In this scenario, the scheduler are supposed
% 		to selects partition P1 and partition P4. This scenario is exactly the same as
% 		illustrated in \figurename ~\ref{figure:pb_scheduling}.

% 	\item Partition P2, P3, and P5 then experienced a failure. In this scenario, the
% 		scheduler are supposed to selects partition P1 and partition P5. This scenario is
% 		done to test the scheduler behavior. The scheduler should still choose a
% 		candidate which meets the running conddition, even when there are backup
% 		partitions, which to be scheduled later than the candidate experienced a
% 		failure.

% \end{enumerate}

% In the first scenario, when all partitions are healthy, the server receive service $A$ from
% partition P1 and service P2 from partition P3. For the second scenario, the server receives
% heartbeat from partition P1 for service $A$ and from partition P4 for service $B$. This means
% the service still functioning correctly even when the original partition which provides the
% service experiencing a failure. On the third scenario, the server still receives heartbeat for
% service $A$ from partition P1 and service $B$ from partition P4. This means failured experienced
% by backup partitions later than the supposed selected partitions do not affect scheduler
% selection.

% In all of these scenarios, all the service required is provided, even though partitions can
% still experience failures as base ARINC 653 scheduler. This means, while this scheme does not
% increases the mean time to failure for each partition, it does increases mean time to failure
% for each service. 

% vim: tw=96
