%! TEX root = ../final-project.tex
\chapter{ANALISIS PERMASALAHAN DAN RANCANGAN SOLUSI}

\section{Analisis Permasalahan}
\label{section:permasalahan}

Standar ARINC 653 berfungsi sebagai panduan pengembangan sistem operasi \textit{real-time} pada
\textit{safety-critical system}.  Banyak faktor yang menentukan apakah sebuah sistem dapat
dikategorikan sebagai \textit{safety-critical system}, salah satunya adalah
\textit{fault-tolerancy}.  Pada \textit{safety\hyp critical system}, \textit{fault-tolerant}
adalah properti yang sangat dicari.  Sistem yang \textit{fault-tolerant} akan memberikan jaminan
bahwa sistem akan terus bekerja sebagaimana seharusnya meskipun terjadi \textit{fault} selama
sistem beroperasi.

Fokus dari standar ARINC 653 adalah menjamin sistem operasi melakukan partisi lingkungan
eksekusi agar aplikasi yang berjalan pada sebuah lingkungan eksekusi tidak mengganggu aplikasi
pada lingkungan eksekusi lainnya. Meski standar tersebut menjamin \textit{fault} yang terjadi
pada sebuah aplikasi tidak akan mengganggu aplikasi lain yang berada pada lingkungan eksekusi
berbeda (\textit{fault containment}), \textit{fault} yang terjadi pada sebuah aplikasi tetap
akan terjadi dan tidak ditangani. Standar ARINC 653 mendefinisikan mekanisme untuk mendeteksi
dan memberikan tanggapan apabila terjadi \textit{fault}.  Namun, standar tersebut tidak
mendefinisikan tanggapan apa yang harus dilakukan untuk menjamin aplikasi yang menghasilkan
\textit{fault} akan terus bekerja. Meskipun aplikasi pada sistem tersebut akan melalui proses
verifikasi untuk menjamin tidak akan terjadi \textit{fault}, proses verifikasi tersebut mungkin
sangat lama atau memiliki \textit{fault} juga.  Karena itu, mekanisme penanganan pada \textit{fault}
tidak dapat diabaikan begitu saja.

\section{Rancangan Solusi}
\label{section:solution}

Solusi dari permasalahan yang dipaparkan pada \autoref{section:permasalahan} adalah dengan
menggunakan \textit{primary-backup scheduling}. Penggunaan skema \textit{primary-backup} dapat
menjamin bahwa aplikasi yang \textit{fault} akan tetap menjalankan \textit{backup} aplikasi
tersebut yang sudah terverifikasi tidak akan mengalami \textit{fault} dalam waktu panjang.
Namun, meski sudah banyak studi mengenai \textit{primary-backup scheduling} \citep{Campbell1986}
\citep{Bertossi2006}, belum ada studi mengenai metode tersebut spesifik pada sistem yang
memenuhi standar ARINC 653. 

Eksperimen \textit{primary-backup scheduling} akan dilakukan pada ARLX, yaitu prototipe sistem
yang bersesuaian dengan spesifikasi ARINC 653 pada Xen. Hal ini dikarenakan prototipe tersebut
tersedia gratis dan \textit{open-source}, sehingga pengembangan dan eksperimen yang akan
dilakukan tidak memerlukan biaya banyak dan dapat dieksplorasi secara mandiri.

\subsection{Implementasi \textit{Primary-Backup Scheduling} pada ARLX}

Pada Xen, sebuah \textit{domain} hanya dapat dibuat oleh dom0 saja.  Aplikasi maupun
\textit{scheduler} tidak dapat membuat \textit{domain} baru apabila aplikasi tersebut mengalami
\textit{fault}.  Agar partisi \textit{backup} dapat berjalan apabila partisi \textit{primary}
mengalami \textit{fault}, maka partisi \textit{backup} sudah harus dibuat oleh dom0 pada tahap
inisialisasi.  \textit{Scheduler} akan memasukkan sebuah partisi pada \textit{major time frame}
pada tahap \textit{scheduling} jika dan hanya jika partisi tersebut merupakan \textit{primary}
dan belum mengalami kegagalan.  Jika terjadi kegagalan pada partisi \textit{primary}, maka
\textit{scheduler} akan memasukkan partisi \textit{backup} yang bersesuaian pada \textit{major
time frame}.  Karena itu, untuk dapat mengimplementasikan \textit{primary-backup scheduling}
pada prototipe ARINC 653, \textit{scheduler} harus dapat mengetahui partisi mana yang merupakan
\textit{primary} atau \textit{backup} agar dapat melakukan \textit{scheduling}.

Selain itu, \textit{scheduler} juga perlu mengetahui kapan sebuah partisi \textit{primary}
dikategorikan mengalami kegagalan.  Karena itu, perlu ada mekanisme untuk mendeteksi
\textit{fault}, dan memberikan informasi tersebut kepada \textit{scheduler}.

\subsection{Informasi Partisi}
\label{section:informasi_partisi}

Agar skema \textit{primary-backup} dapat dilakukan, \textit{scheduler} harus mengetahui beberapa
informasi terkait keadaan partisi agar dapat menentukan partisi mana yang harus mendapatkan
waktu CPU. \textit{Scheduler} harus mengetahui apakah partisi tersebut mengalami
\textit{failure} atau tidak. Apabila partisi sedang mengalami kegagalan, maka partisi tidak
boleh mendapatkan jatah waktu CPU. Selain itu, \textit{scheduler} juga harus mengetahui
layanan apa saja yang sudah dikerjakan sebelumnya pada \textit{major time frame} saat
ini. Dengan demikian, partisi yang memiliki layanan yang tidak bersifat
\textit{idempotent} tidak akan mendapatkan waktu CPU lebih dari sekali dan partisi yang memiliki
layanan yang bersifat \textit{idempotent} tidak akan membuang waktu CPU. Kedua hal
tersebut dapat dilakukan dengan menyimpan informasi berupa keadaan partisi dan identifikasi
layanan yang berada pada partisi tersebut.

Informasi mengenai keadaan partisi dapat disimpan dengan menggunakan \textit{boolean}. Informasi
mengenai identifikasi layanan yang terdapat pada partisi dapat disimpan menggunakan
identifikasi partisi, dengan asumsi layanan yang terdapat hubungan satu ke satu antara
layanan dengan partisi sehingga identifikasi partisi dapat digunakan untuk mengidentifikasi
layanan. Kedua informasi ini akan dapat diubah dengan menggunakan xl melalui dom0.

\subsection{Algoritma \textit{Scheduling}}
\label{section:algoritma_scheduling}

Algoritma \textit{scheduling} pada sistem \textit{real-time} harus deterministik agar
administrator sistem dapat mengatur konfigurasi proses-proses \textit{real-time} sehingga
memenuhi batasan-batasan masing-masing proses. Agar algoritma \textit{scheduling} tetap
deterministik, algoritma tersebut harus tidak bergantung pada sumber eksternal. Dengan demikian,
algoritma \textit{primary-backup scheduling} yang dibuat harus secara penuh bergantung kepada
informasi masing-masing partisi. \textit{Scheduler} akan memberikan waktu CPU kepada partisi
yang tidak sedang mengalami \textit{failure} dan layanan tersebut belum pernah
disediakan. Sebuah layanan dikatakan belum pernah disediakan jika dan hanya jika dan
hanya jika tidak ada partisi dengan layanan yang sama dengan layanan partisi
tersebut yang sudah diberikan waktu CPU pada suatu \textit{major time frame}.

Pengecekan partisi yang dilakukan oleh \textit{scheduler} harus dibuat sedemikian sehingga tidak
terjadi perubahan signifikan pada penggunaan memori dan waktu. Pengecekan keadaan partisi dapat
dilakukan dengan mudah. Untuk melakukan pengecekan apakah terdapat layanan pada partisi
yang menjadi kandidat belum pernah disediakan, perlu ada sebuah penanda untuk masing-masing
layanan. Hal ini dapat dilakukan dengan menggunakan struktur data \textit{array} dengan
ukuran sejumlah banyaknya partisi maximum yang dapat terdaftar sebagai masukkan dari algoritma
\textit{scheduling} pada suatu waktu. \textit{Array} ini akan memiliki indeks identifikasi
layanan. Karena identifikasi layanan sama dengan identifikasi partisi, maka
nilai yang mungkin dari identifikasi layanan ada diantara $1$ sampai dengan $N$ dengan
$N$ adalah jumlah partisi yang tersedia. Dengan demikian, memori tambahan yang diperlukan untuk
algoritma \textit{primary-backup scheduling} linear terhadap maximum jumlah partisi yang akan
dijadwalkan. Karena memori tambahan yang diperlukan sama dengan memori yang diperlukan untuk
daftar partisi yang akan dijadwalkan, maka kompleksitas memori yang dibutuhkan tidak berubah.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[
		partition-done/.style={fill=gray, fill opacity=0.10, text opacity=1.0},
		partition-healthy/.style={fill=green, fill opacity=0.30, text
		opacity=1.0},
		partition-failed/.style={fill=red, fill opacity=0.40, text opacity=1.0},
		candidate/.style={very thick},
		]

		\def\boxs{30pt}
		\def\legends{10pt}
		\def\off{10pt}
		\def\loff{2pt}
		\def\shape{rectangle +(\boxs,\boxs)}
		\def\partnode{node[pos=0.5,font=\small]}
		\def\lshape{rectangle +(\legends,\legends)}
		\newcommand\lnode[1]{node[pos=0.5,align=right,label={[anchor=west,font=\footnotesize]right:#1}] {}}

		\draw[partition-healthy]           (0*\boxs,{0*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-healthy]           (1*\boxs,{0*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-failed]            (2*\boxs,{0*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-healthy]           (3*\boxs,{0*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-healthy]           (4*\boxs,{0*(-\boxs-\off)}) \shape \partnode {P5-SB};

		\draw[partition-healthy,candidate] (0*\boxs,{1*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-healthy]           (1*\boxs,{1*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-failed]            (2*\boxs,{1*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-healthy]           (3*\boxs,{1*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-healthy]           (4*\boxs,{1*(-\boxs-\off)}) \shape \partnode {P5-SB};

		\draw[partition-done]              (0*\boxs,{2*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-done,candidate]    (1*\boxs,{2*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-failed]            (2*\boxs,{2*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-healthy]           (3*\boxs,{2*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-healthy]           (4*\boxs,{2*(-\boxs-\off)}) \shape \partnode {P5-SB};

		\draw[partition-done]              (0*\boxs,{3*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-done]              (1*\boxs,{3*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-failed,candidate]  (2*\boxs,{3*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-healthy]           (3*\boxs,{3*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-healthy]           (4*\boxs,{3*(-\boxs-\off)}) \shape \partnode {P5-SB};

		\draw[partition-done]              (0*\boxs,{4*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-done]              (1*\boxs,{4*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-failed]            (2*\boxs,{4*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-healthy,candidate] (3*\boxs,{4*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-healthy]           (4*\boxs,{4*(-\boxs-\off)}) \shape \partnode {P5-SB};

		\draw[partition-done]              (0*\boxs,{5*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-done]              (1*\boxs,{5*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-done]              (2*\boxs,{5*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-done]              (3*\boxs,{5*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-done,candidate]    (4*\boxs,{5*(-\boxs-\off)}) \shape \partnode {P5-SB};

		\draw[partition-done]              (0*\boxs,{6*(-\boxs-\off)}) \shape \partnode {P1-SA};
		\draw[partition-done]              (1*\boxs,{6*(-\boxs-\off)}) \shape \partnode {P2-SA};
		\draw[partition-done]              (2*\boxs,{6*(-\boxs-\off)}) \shape \partnode {P3-SB};
		\draw[partition-done]              (3*\boxs,{6*(-\boxs-\off)}) \shape \partnode {P4-SB};
		\draw[partition-done]              (4*\boxs,{6*(-\boxs-\off)}) \shape \partnode {P5-SB};

		% legends
		\draw[candidate] (0pt,{6*(-\boxs-\off)-0*(\legends+\loff)-\legends-\off}) \lshape
		\lnode{Partisi kandidat};

		\draw[partition-healthy]
		(0pt,{6*(-\boxs-\off)-1*(\legends+\loff)-\legends-\off}) \lshape
		\lnode{Partisi baik};

		\draw[partition-failed]
		(0pt,{6*(-\boxs-\off)-2*(\legends+\loff)-\legends-\off}) \lshape
		\lnode{Partisi gagal};

		\draw[partition-done]
		(0pt,{6*(-\boxs-\off)-3*(\legends+\loff)-\legends-\off}) \lshape
		\lnode{Layanan pada partisi telah disediakan};

	\end{tikzpicture}
	\caption{Primary-backup scheduling}
	\label{figure:pb_scheduling}
\end{figure}

Illustrasi bagaimana algoritma \textit{primary-backup scheduling} pada \textit{scheduler} ARINC
653 dapat dilihat pada \autoref{figure:pb_scheduling}. Scheduler memiliki daftar partisi yang
akan dijadwalkan. Setiap partisi memiliki informasi partisi seperti yang telah dijelaskan pada
\autoref{section:informasi_partisi}. Pada \autoref{figure:pb_scheduling}, partisi diberi label
dengan format P$X$-S$Y$, yang berarti partisi $X$ akan menyediakan layanan $Y$ jika
diberikan waktu CPU oleh \textit{scheduler}. Pada skenario tersebut, \textit{scheduler} akan
bekerja sebagai berikut:

\begin{itemize}

	\item Pada partisi P1, partisi tidak sedang mengalami kegagalan dan
		layanan $A$ belum pernah disediakan, sehingga partisi diberikan waktu
		CPU oleh \textit{scheduler}.

	\item Pada partisi P2, partisi tidak diberikan waktu CPU karena pada saat partisi P1
		sudah menghabiskan kuantumnya, layanan $A$ sudah pernah disediakan.

	\item Pada partisi P3, layanan pada partisi tersebut belum pernah disediakan,
		namun partisi sedang mengalami kegagalan sehingga partisi tidak diberikan waktu
		CPU.

	\item Partisi P4 tidak sedang mengalami kegagalan dan karena partisi P3 tidak diberikan
		waktu CPU, layanan $B$ belum pernah disediakan. Karena semua kondisi
		memenuhi, maka partisi P4 diberikan waktu CPU oleh \textit{scheduler}.

	\item Partisi P5 tidak diberikan waktu CPU karena layanan $B$ sudah pernah
		disediakan.

\end{itemize}

Pada akhir dari \textit{major time frame}, algoritma ini menjamin setiap layanan pernah
disediakan apabila terdapat setidaknya satu partisi yang memiliki layanan tersebut yang
tidak sedang mengalami kegagalan. Algoritma ini akan berulang secara terus menerus tiap akhir
\textit{major time frame}.

\subsection{Pengujian Keandalan}

Untuk mengukur peningkatan keandalan sistem akibat penggunaan \textit{primary-backup scheduler},
sistem akan menjalani pengujian keandalan pada saat menggunakan \textit{scheduler} tersebut.
Tujuan utama dari pengujian keandalan adalah untuk mengukur \textit{mean time to failure} sistem
tersebut. Untuk mempermudah pengukuran, asumsikan bahwa sistem akan selalu mengalami kegagalan
apabila terdapat sebuah layanan pada sistem tersebut yang mengalami kegagalan dan
layanan-layanan merupakan komponen paling tidak andal pada sistem. Dengan demikian, \textit{mean
time to failure} sistem sama dengan minimum dari \textit{mean time to failure} seluruh layanan
yang terdapat pada sistem tersebut. Keandalan sistem dikatakan meningkat saat menggunakan
\textit{primary-backup scheduler} apabila \textit{mean time to failure} sistem tersebut menjadi
lebih lama. Selain itu, hasil pengujian dapat digunakan untuk menentukan apakah algoritma
bekerja seperti yang seharusnya.

Pengujian keandalan dilakukan dengan melakukan pengecekan apakah setiap partisi dapat
mengirimkan \textit{heartbeat} dengan baik. Sebuah partisi dikatakan dapat mengirim
\textit{heartbeat} apabila partisi mengirimkan \textit{heartbeat} jika dan hanya jika partisi
tersebut memenuhi kondisi untuk mendapatkan waktu CPU. Cara termudah untuk melakukan pengujian
tersebut adalah dengan menggunakan kerangka uji dengan arsitektur \textit{server-client}. Setiap
partisi berlaku sebagai \textit{client} dan \textit{server} dapat berupa mesin apapun, selama
mesin tersebut terhubung dengan seluruh partisi. Kemudian, setiap partisi mengirimkan
\textit{heartbeat} dengan selang waktu tertentu kepada \textit{server}. Selang waktu harus
dipilih sedemikian sehingga setiap partisi akan memberikan layanan tersebut apabila mendapatkan
waktu CPU. Kemudian, \textit{server} akan mencatat setiap layanan sudah pernah disediakan pada
tiap akhir \textit{major time frame}.

% vim: tw=96
