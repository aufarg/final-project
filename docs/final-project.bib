@article{AirlinesElectronicEngineeringCommittee2012,
abstract = {Subset services},
author = {{Airlines Electronic Engineering Committee}},
file = {:home/dancinggrass/Books/ARINC 653P1-3.pdf:pdf},
isbn = {ARINC Specification 653},
journal = {Arinc 653},
pages = {85},
title = {{653P1-3 Avionics Application Software Standard Interface Part 1 - Required Services}},
year = {2012}
}
@article{Al-Omari2004,
abstract = {In real-time systems, tasks have deadlines to be met despite the presence of faults. Primary-Backup (PB) scheme is one of the most important schemes that has been employed for fault-tolerant scheduling of real-time tasks, wherein each task has two versions and the versions are scheduled on two different processors with time exclusion. There have been techniques proposed for improving schedulability of the PB-based scheduling, of which Backup-Backup (BB) overloading is among the most popular ones. In this technique two or more backups can share/overlap in time on a processor. In this paper, we propose two new techniques that accommodate more tasks and/or tolerate faults effectively. In the first technique, called dynamic grouping, the processors are dynamically grouped into logical groups in order to achieve efficient overloading of tasks on resources, thereby improving the schedulability and the reliability of the system. In the second technique, called PB overloading, the primary of a task can share/overlap in time with the backup of another task on a processor. The intuition is that, for a primary (or backup), the PB-overloading can assign an earlier start time than that of the BB-overloading, thereby increasing the schedulability. We conduct schedulability and reliability analysis of the proposed techniques through simulation and analytical studies. Our studies show that dynamic grouping improves the schedulability more than static grouping, and offers graceful degradation with increasing faults. Also, PB-overloading improves the schedulability more than BB-overloading, and offers reliability comparable to that of BB-overloading. The proposed techniques are generic that they can be incorporated into many fault-tolerant non-preemptive scheduling algorithms. ?? 2004 Elsevier Inc. All rights reserved.},
author = {Al-Omari, Ra'ed and Somani, Arun K. and Manimaran, G.},
doi = {10.1016/j.jpdc.2004.03.015},
file = {:home/dancinggrass/Downloads/alomari2004.pdf:pdf},
issn = {07437315},
journal = {Journal of Parallel and Distributed Computing},
keywords = {Fault-tolerance,Multiprocessors,Real-time systems,Reliability,Schedulability,Scheduling},
number = {5},
pages = {629--648},
title = {{Efficient overloading techniques for primary-backup scheduling in real-time systems}},
volume = {64},
year = {2004}
}
@inproceedings{Bertossi2006,
abstract = {This paper presents several fault-tolerant extensions of the Rate-Monotonic First-Fit multiprocessor scheduling algorithm handling both active and passive task copies. In particular, the technique of backup phasing delay is used to reduce the portions of active task copies that must be always executed and to deallocate active task copies as soon as their primary task copies have been successfully executed. It is also shown how to employ this technique while considering passive task duplication so as to over-book each processor with many passive task copies, assigning tasks to processors in such a way that tasks with equal or multiple periods have a high chance to be assigned to the same processor, and partitioning the processors into groups to avoid the mix of primary, active, and passive task copies on the same processor. Extensive simulations reveal a remarkable saving of both the overall number of processors used and the total computation time of the schedulability test (achieved especially by two new algorithms, called ARR3 and S-PR-PASS) with respect to previously proposed algorithms},
author = {Bertossi, Alan A. and Mancini, Luigi V. and Menapace, Alessandra},
booktitle = {Proceedings - IEEE International Symposium on Distributed Simulation and Real-Time Applications, DS-RT},
doi = {10.1109/DS-RT.2006.33},
file = {:home/dancinggrass/Downloads/bertossi2006.pdf:pdf},
isbn = {0769526977},
issn = {15506525},
keywords = {Fault-tolerance,Hard-real-time systems,Multi-processors,Periodic tasks,Rate-monotonic scheduling},
pages = {107--116},
title = {{Scheduling hard-real-time tasks with backup phasing delay}},
year = {2006}
}
@article{Campbell1986,
author = {Campbell, R O Y H},
file = {:home/dancinggrass/Downloads/liestman1986.pdf:pdf},
number = {11},
pages = {1089--1095},
title = {{A Fault-Tolerant Scheduling Problem}},
year = {1986}
}
@book{Chisnall2014,
abstract = {Xen is a virtualization tool, but what does this mean? In this chapter, we will explore some of the history of virtualization, and some of the reasons why people found, and continue to find, it useful. We will have a look in particular at the x86, or IA32, architecture, why it presents such a problem for virtualization, and some possible ways around these limitations from other virtualization systems and finally from Xen itself.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Chisnall, David},
booktitle = {Psychological Science},
doi = {10.1007/s13398-014-0173-7.2},
eprint = {arXiv:1011.1669v3},
file = {:home/dancinggrass/Books/System/Realtime Xen/00-The Definitive Guide to the Xen Hypervisor.pdf:pdf},
isbn = {9780874216561},
issn = {1467-9280},
keywords = {xen hypervisor virtualization},
number = {9},
pages = {307},
pmid = {25052830},
title = {{The Definitive Guide to the Xen Hypervisor}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/15003161{\%}5Cnhttp://cid.oxfordjournals.org/lookup/doi/10.1093/cid/cir991{\%}5Cnhttp://www.scielo.cl/pdf/udecada/v15n26/art06.pdf{\%}5Cnhttp://www.scopus.com/inward/record.url?eid=2-s2.0-84861150233{\&}partnerID=tZOtx3y1},
volume = {25},
year = {2014}
}
@article{Choudhary2011,
abstract = {Software fault tolerance can itself be dangerous error-prone because of the additional effort that must be included in the programming process. The paper is based upon research in the area of testing software fault tolerance techniques. A Framework to Test Fault Tolerance has been proposed and validated with industry data. During the validation process we identified some of the interesting findings that can be explored to carry out further research in this area.},
author = {Choudhary, R. K. and Khan, R. A.},
doi = {10.1145/1968587.1968604},
file = {:home/dancinggrass/Downloads/choudhary2011.pdf:pdf},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {fault tolerance,framework,software faults,testing techniques},
number = {3},
pages = {1--5},
title = {{Testing Software Fault Tolerance Techniques- Future Direction}},
url = {http://dl.acm.org/citation.cfm?id=1968587.1968604{\%}5Cnhttp://portal.acm.org/citation.cfm?doid=1968587.1968604},
volume = {36},
year = {2011}
}
@article{Garside2009,
abstract = {Traditionally, airplane systems have been designed and implemented in a federated fashion with each system providing for its own needs. A typical airplane system could be made up of one or more black boxes each having its own enclosure and providing for its own power conditioning and cooling needs. I/O signal conditioning and computational processing necessary to provide the intended function is also provided on a box-by-box basis. With each new generation of airplanes, the number of systems increased. Driven by market forces the need grew to reduce weight and electrical power to keep the airplane fuel efficient, cost-effective, and competitive. To address this contradiction, the Integrated Modular Avionics (IMA) concept was born. Within IMA architectures, avionics functions share common resources. Multiple black boxes are optimized to the minimum IMA resources necessary. This optimization provides the sought-after weight and power savings, and also provides for a much reduced number of parts to be maintained and controlled. These are all beneficial for the airplane manufacturer and airplane operator. However, MIMA architectures present some unique challenges during their development and integration. This will explore some of the more significant of these integration challenges associated with IMA architectures, including: What is the system? For the supplier whose system has been selected to be hosted on the IMA platform, the boundaries can be unclear. What was once a box with circuit cards and substance has been abstracted to a software application. Connection to other systems or to sensorsteffectors was via airplane wiring. Now, complex in-line electronics modules exist that the supplier knows little or nothing about. For the provider of the IMA platform, the system may be defined as a set of available resources (processing, communication, 1/0, etc.) to be shared by the systems to be hosted. To the airplane manufacturer the system is a working suite of avionics. - With the LMA approach: "Who is responsible for ensuring that boundaries and expectations are clearly defined and understood so that nothing gets overlooked?" Who is the system integrator? Within the IMA environment the answer changes depending on your perspective. The supplier of a hosted function may be considered responsible for the integration of their system components. The IMA platform provider may believe they are responsible for the platform elements. The airplane manufacturer wants an integrated solution. With the IMA approach: "Who is responsible for ensuring that the whole is equal to the sum of its parts?" How is the integration of an IMA architecture handled? As more and more of the hosted systems are brought together, IMA architectures can present challenges not seen with federated systems. The nature of IMA architectures requires more of the components to be available and working to allow seemingly simple tasks to take place. With the IMA approach: "Who is responsible for ensuring that this integration is planned and executed in the optimum sequence?"},
author = {Garside, Richard and Pighetti, F. Joe},
doi = {10.1109/MAES.2009.4811086},
file = {:home/dancinggrass/Downloads/garside2007.pdf:pdf},
isbn = {1424411084},
issn = {08858985},
journal = {IEEE Aerospace and Electronic Systems Magazine},
number = {3},
pages = {31--34},
title = {{Integrating modular avionics: A new role emerges}},
volume = {24},
year = {2009}
}
@article{Haritsa1992,
author = {Haritsa, Jayant R. and Carey, Michael J. and Livny, Miron},
doi = {10.1007/BF00365312},
file = {:home/dancinggrass/Downloads/haritsa1992.pdf:pdf},
issn = {09226443},
journal = {Real-Time Systems},
number = {3},
pages = {203--241},
title = {{Data access scheduling in firm real-time database systems}},
volume = {4},
year = {1992}
}
@article{Jin2013,
author = {Jin, Hyun-Wook and Hyun-Wook},
doi = {10.1145/2583687.2583693},
file = {:home/dancinggrass/Downloads/apres-3.pdf:pdf},
issn = {15513688},
journal = {ACM SIGBED Review},
number = {4},
pages = {25--28},
title = {{Fault-tolerant hierarchical real-time scheduling with backup partitions on single processor}},
url = {http://dl.acm.org/citation.cfm?doid=2583687.2583693},
volume = {10},
year = {2013}
}
@inproceedings{Littlefield-Lawwill2008,
abstract = {Projeto de arquiteturas IMA considerando aspectos de particionamento (time-space partitioning)},
author = {Littlefield-Lawwill, Justin and Kinnan, Larry},
booktitle = {AIAA/IEEE Digital Avionics Systems Conference - Proceedings},
doi = {10.1109/DASC.2008.4702751},
file = {:home/dancinggrass/Downloads/littlefieldlawwill2008.pdf:pdf},
isbn = {9781424422081},
pages = {1--11},
title = {{System considerations for robust time and space partitioning in integrated modular avionics}},
year = {2008}
}
@article{Oh1994,
author = {Oh, Yingfeng and Son, Sang H},
file = {:home/dancinggrass/Downloads/oh1994.pdf:pdf},
pages = {315--329},
title = {{Enhancing Fault-Tolerance in Rate-Monotonic Scheduling}},
volume = {329},
year = {1994}
}
@article{Rushby2000,
abstract = {Automated aircraft control has traditionally been divided into distinct "functions" that are implemented separately (e.g., autopilot, autothrottle, flight management); each function has its own fault-tolerant computer system, and dependencies among different functions are generally limited to the exchange of sensor and control data. A by-product of this "federated" architecture is that faults are strongly contained within the computer system of the function where they occur and cannot readily propagate to affect the operation of other functions. More modern avionics architectures contemplate supporting multiple functions on a single, shared, fault-tolerant computer system where natural fault containment boundaries are less sharply defined. Partitioning uses appropriate hardware and software mechanisms to restore strong fault containment to such integrated architectures. This report examines the requirements for partitioning, mechanisms for their realization, and issues in providing assurance for partitioning. Because partitioning shares some concerns with computer security, security models are reviewed and compared with the concerns of partitioning.},
author = {Rushby, John},
doi = {DOT/FAA/AR-99/58},
file = {:home/dancinggrass/Downloads/faaversion.pdf:pdf},
journal = {Work},
number = {March},
pages = {67},
title = {{Partitioning in avionics architectures: requirements, mechanisms and assurance}},
year = {2000}
}
@article{Shin1994,
abstract = {This paper surveys the state of the art in real-time computing. It$\backslash$nintroduces basic concepts and identifies key issues in the design of$\backslash$nreal-time systems. Solutions proposed in literature for tackling these$\backslash$nissues are also briefly discussed},
author = {Shin, Kang G. and Ramanathan, Parameswaran},
doi = {10.1109/5.259423},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Shin, Ramanathan - 1994 - Real-Time Computing A New Discipline of Computer Science and Engineering.pdf:pdf},
issn = {15582256},
journal = {Proceedings of the IEEE},
number = {1},
pages = {6--24},
pmid = {16856666},
title = {{Real-Time Computing: A New Discipline of Computer Science and Engineering}},
volume = {82},
year = {1994}
}
@book{Tanenbaum2014,
abstract = {For software development professionals and computer science students, Modern Operating Systems gives a solid conceptual overview of operating system design, including detailed case studies of Unix/Linux and Windows 2000. Readers familiar with Tanenbaum's previous text, Operating Systems, know the author is a great proponent of simple design and hands-on experimentation. His earlier book came bundled with the source code for an operating system called Minux, a simple variant of Unix and the platform used by Linus Torvalds to develop Linux. Although this book does not come with any source code, he illustrates many of his points with code fragments (C, usually with Unix system calls). The first half of Modern Operating Systems focuses on traditional operating systems concepts: processes, deadlocks, memory management, I/O, and file systems. There is nothing ground-breaking in these early chapters, but all topics are well covered, each including sections on current research and a set of student problems. It is the second half of the book that differentiates itself from older operating systems texts. Here, each chapter describes an element of what constitutes a modern operating system-awareness of multimedia applications, multiple processors, computer networks, and a high level of security. The chapter on multimedia functionality focuses on such features as handling massive files and providing video-on-demand. Included in the discussion on multiprocessor platforms are clustered computers and distributed computing. Finally, the importance of security is discussed-a lively enumeration of the scores of ways operating systems can be vulnerable to attack, from password security to computer viruses and Internet worms. Included at the end of the book are case studies of two popular operating systems: Unix/Linux and Windows 2000. There is a bias toward the Unix/Linux approach, not surprising given the author's experience and academic bent, but this bias does not detract from Tanenbaum's analysis. Both operating systems are dissected, describing how each implements processes, file systems, memory management, and other operating system fundamentals. Tanenbaum's mantra is a simple, accessible operating system design. Given that modern operating systems have extensive features, he is forced to reconcile physical size with simplicity. Towards this end, he makes frequent references to the Frederick Brooks classic The Mythical Man Month for wisdom on managing large, complex software development projects. He finds both Windows 2000 and Unix/Linux guilty of being too complicated-with a particular skewering of Windows 2000 and its "mammoth Win32 API". A primary culprit is the attempt to make operating systems more "user-friendly," which Tanenbaum views as an excuse for bloated code. The solution is to have smart people, the smallest possible team, and well-defined interactions between various operating systems components. Future operating system design will benefit if the advice in this book is taken to heart. -Pete Ostenson - Dieser Text bezieht sich auf eine vergriffene oder nicht verf{\"{u}}gbare Ausgabe dieses Titels.},
archivePrefix = {arXiv},
arxivId = {0710.2023},
author = {Tanenbaum, Andrew S. and Bos, Herbert},
booktitle = {Education},
doi = {10.1142/S0129183108012261},
eprint = {0710.2023},
file = {:home/dancinggrass/Downloads/Operating.Systems.4th.Edi.pdf:pdf},
isbn = {9780133591620},
issn = {13541013},
pages = {1137},
pmid = {12204814},
title = {{Modern Operating Systems}},
url = {http://www.amazon.com/dp/0136006639},
volume = {2},
year = {2014}
}
@inproceedings{VanderLeest2010,
abstract = {We have developed an early prototype of an ARINC 653 implementation using the virtualization technology of the open source Xen hypervisor along with a Linux-based domain/partition OS. In this paper we share lessons learned from adding to our prototype both an ARINC 653 CPU scheduler and a simple ARINC 653 serial I/O driver. By using a common hypervisor technology on multiple platforms, early application development can be done in a PC environment with relatively good modeling of the final target's behavior. The paper covers three topics. First, we start with an overview of the ARINC 653 standard, which is important because it reduces development costs, reduces system weight, and lowers certification costs. The standard focuses on resource partitioning of time and space on an avionics computer, managing the three primary subsystems of the computer: Central Processing Unit (CPU), Memory, and Input/Output (I/O). Second, we will review virtualization technology, an established method of sharing a computing resource, considering it for adaptation to ARINC 653. Third, as a case study, we will examine our prototype implementation of the ARINC 653 standard using the Xen open source hypervisor. We conclude with a discussion of our plans for future work towards ARINC 653 simulation and development environments on both PC desktop and embedded targets.},
author = {VanderLeest, Steven H.},
booktitle = {AIAA/IEEE Digital Avionics Systems Conference - Proceedings},
doi = {10.1109/DASC.2010.5655298},
file = {:home/dancinggrass/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/VanderLeest - 2010 - ARINC 653 hypervisor.pdf:pdf},
isbn = {9781424466160},
issn = {2155-7195},
title = {{ARINC 653 hypervisor}},
year = {2010}
}

